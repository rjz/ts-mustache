// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Parser full tests handles nested properties 1`] = `
"type MustacheValue = string | number | boolean | () => MustacheTemplate

type MustacheRecord<T> = T

interface Test {
  foo: MustacheRecord<TestFoo>
}

interface TestFoo {
  bar: MustacheValue
}

export type TemplateMap = {
  'test': Test,
}

export type TemplateName = keyof TemplateMap

export const TEMPLATES = [
  'test',
] as const"
`;

exports[`Parser full tests handles nested properties in sections 1`] = `
"/**
 * Placeholder for (not-yet-interpolated) content supplied or returned by
 * lambda functions.
 *
 * Note that because interpolation/transformation can take place outside the
 * template (see notes for {@link @MustacheSectionLambda}) the content and its
 * types can't be reliably inferred by the type system.
 */
type MustacheTemplate = string

/**
 * Placeholder for evaluating a lambda invoked as a Section value.
 *
 * Be careful with these: a permissive type reflects both an unknown
 * transformation inside the lambda and an easily-overlooked escape hatch from
 * the template's generated types.
 *
 *  @see {@link https://github.com/mustache/spec/blob/master/specs/~lambdas.yml}
 */
interface MustacheSectionLambda {
  (content: MustacheTemplate) => MustacheTemplate
}

type MustacheValue = string | number | boolean | () => MustacheTemplate

type MustacheRecord<T> = T

type MustacheSection<T> = T[] | T | MustacheSectionLambda

interface Test {
  foo: MustacheRecord<TestFoo>
}

interface TestFoo {
  bar?: MustacheSection<TestFooBar>
}

interface TestFooBar {
  pleaseDontButOk: MustacheValue
}

export type TemplateMap = {
  'test': Test,
}

export type TemplateName = keyof TemplateMap

export const TEMPLATES = [
  'test',
] as const"
`;

exports[`Parser full tests works 1`] = `
"/**
 * Placeholder for (not-yet-interpolated) content supplied or returned by
 * lambda functions.
 *
 * Note that because interpolation/transformation can take place outside the
 * template (see notes for {@link @MustacheSectionLambda}) the content and its
 * types can't be reliably inferred by the type system.
 */
type MustacheTemplate = string

/**
 * Placeholder for evaluating a lambda invoked as a Section value.
 *
 * Be careful with these: a permissive type reflects both an unknown
 * transformation inside the lambda and an easily-overlooked escape hatch from
 * the template's generated types.
 *
 *  @see {@link https://github.com/mustache/spec/blob/master/specs/~lambdas.yml}
 */
interface MustacheSectionLambda {
  (content: MustacheTemplate) => MustacheTemplate
}

type MustacheValue = string | number | boolean | () => MustacheTemplate

type MustacheSection<T> = T[] | T | MustacheSectionLambda

interface _person {
  name: MustacheValue
  age: MustacheValue
}

interface Nametag {
  person?: MustacheSection<NametagPerson>
  name: MustacheValue
}

interface NametagPerson {
  name: MustacheValue
  age: MustacheValue
}

interface Profile {
  name: MustacheValue
  age: MustacheValue
}

export type TemplateMap = {
  '_person': _person,
  'nametag': Nametag,
  'profile': Profile,
}

export type TemplateName = keyof TemplateMap

export const TEMPLATES = [
  '_person',
  'nametag',
  'profile',
] as const"
`;
